/*! \mainpage Práctica5: TDAs no lineales. Solver juego de palabras

@image html logo_scrabble.png

# Introducción

Buenas, somos Adrián Jaén Fuentes y Javier Gómez López, del grupo A2 del DGIIM.

En esta práctica y las prácticas siguientes construiremos las estructuras de datos adecuadas para resolver el problema
de las letras del juego televisivo de cifras y letras, así como programas que nos permitan obtener la solución a una
partida.

Esta parte del juego consiste en formar la mejor palabra posible (dependiendo de uno de los dos
criterios que explicamos a continuación) a partir de un conjunto de letras extraídas al azar de una
bolsa. Por ejemplo, dadas las siguientes letras:
O D Y R M E T
una buena solución posible sería METRO. El número de letras que se juegan en cada partida se
decide de antemano, y las letras disponibles pueden repetirse. Existen dos modalidades de juego:
- Juego a longitud: En este modo de juego, se tiene en cuenta sólo la longitud de las palabras, y gana la palabra más
larga encontrada
- Juego a puntos: En este modo de juego, a cada letra se le asigna una puntuación, y la puntuación de la palabra será
igual a la suma de las puntuaciones de las letras que la componen

Estaremos especialmente interesados en dar una buena solución al problema de las letras. En esta
primera práctica, estudiaremos qué información necesitamos almacenar, y cuál es la forma más
adecuada de almacenarla, para poder jugar una partida al juego de las letras. En las prácticas
siguientes, estudiaremos dos formas distintas de resolver el juego, que dependerá en parte de la
estructura de datos subyacente.

# Ejecutables

--

## conjunto_letras

Para probar el funcionamiento de el TDA LettersSet, implementaremos un pequeño programa que recibirá dos argumentos:

- Ruta al archivo con información sobre el conjunto de letras
- Palabra de la que calcular la puntuación

> __conjunto_letras__ \<Ruta input> \<Palabra>

@param <Ruta input> Ruta del archivo que contiene la información sobre el conjunto de letras
@param <Palabra> Palabra de la que calcular la puntuación
@return La puntuación de la palabra introducida

--

## bolsa

Para probar el correcto funcionamiento de este TDA, implementaremos un pequeño programa en el
archivo bolsa.cpp, que se encargará de recibir una serie de argumentos de main:

- El primer argumento podrá ser una letra C o una letra I. Dependiendo de la letra,
trabajaremos con una bolsa de caracteres (C) o una bolsa de enteros (I).
- El resto de argumentos serán una lista de enteros o caracteres (según corresponda), que
deberán meterse todos en la bolsa, y después ser extraídos aleatoriamente hasta que la
bolsa quede vacía.

> __bolsa__ \<Tipo(Char o Int)> \<Elementos (Enteros o Caracteres)>
Se elige un tipo de bolsa y se introducen los datos que se quieran
@param <Tipo> Letra C (char) o I (int)
@param <Elementos> Enteros o Caracteres que se introducen a la bolsa
@return Los elementos extraídos de la bolsa desordenados


--

## bolsa_letras

Para comprobar el funcionamiento del TDA LettersBag, implementaremos un programa de prueba que
realice las siguientes operaciones:

- Cree un conjunto de letras (LettersSet), y lo rellene a partir de la información leída de un
archivo.
- Cree una bolsa de letras (LettersBag), y la rellene con la información del LettersSet anterior
- Extraiga todas las letras de la LettersBag (aleatoriamente) y las imprima por pantalla.

> __bolsa_letras__ \<Archivo>
@param <Archivo> Dirección del archivo que contiene los datos del LettersSet.
@return Los elementos extraídos de la bolsa de letras desordenados

--

## palabras_longitud

Para probar el funcionamiento del TDA Dictionary, implentamos un programa de prueba que realice las siguientes
operaciones:

- Construye un Dictionary con el fichero de las palabras
- Extra de dicho diccionario las palabras de la longitud que buscamos
- Imprime dichas palabras por pantalla

> __palabras_longitud__ \<Ruta input> \<int>
@param <Ruta input> Dirección del archivo que contiene las palabras de un diccionario
@param <int> Entero con la logitud de las palabras que buscamos
@post Muestra por pantalla las palabras del diccionario que tienen una longitud \<int>

--

## cantidad_letras

Para realizar otra prueba al funcionamiento de nuestro TDA Dictionary, implementamos un programa de prueba que realice
las siguientes operaciones:

- Construye un Dictionary con el fichero de palabras
- Construye un LettersSet con el fichero de letras
- Imprime por pantalla, para cada letra del LettersSet, el número de ocurrencias de la letra en el diccionario y
su frecuencia relativa

> __cantidad_letras__ \<Input diccionario> \<Input letras>
@param <Input diccionario> Ruta del archivo que contiene las palabras de un diccionario
@param <Input letras> Ruta del archivo que contiene la información de las letras
@post Muestra por pantalla, para cada letra del LettersSet, el número de ocurrencias de la letra en el diccionario y
su frecuencia relativa

--

## partida_letras

Para realizar una prueba al funcionamiento de nuestro TDA Solver, implementamos un programa de prueba que realice
las siguientes operaciones:

- Construye una Bag con el número de letras indicado como argumento
- Usa la clase Solver para encontrar las soluciones al juego de las letras para las letras de la Bag
- Imprime por pantalla las letras disponibles, las posibles soluciones y la puntuación dependiendo si es juego a puntos
o a longitud

> __partida_letras__ \<Archivo letras> \<Archivo diccionario> \<Modo de juego(L o P)> \<Num letras>
@param <Archivo letras> Ruta del archivo que contiene la cantidad de letras y su puntuacion
@param <Input letras> Ruta del archivo que contiene las palabras de un diccionario
@post Imprime por pantalla las letras disponibles, las posibles soluciones y la puntuación dependiendo si es juego a
puntos o a longitud

--

# Análisis de la complejidad computacional O-grande

A continuación, procederemos a el análisis de todos los métodos utilizados por el TDA Solver así como el de resto de
TDAs.

--

## TDA LettersSet

Estudiaremos la eficiencia de los métodos utilizados en el TDA LettersSet:

### LettersSet()

~~~cpp
LettersSet::LettersSet(){
    letters.clear() //O(n)
}
~~~

La complejidad computacional del constructor sin argumentos es O(n) pues el método `clear()`
del TDA `map` de la STL tiene complejidad O(n).


### LettersSet(const LettersSet &other)

~~~cpp
LettersSet::LettersSet(const LettersSet &other) {
    letters = other.letters; //O(n)
}
~~~

La complejidad computacional del constructor de copia es O(n) pues el operador `=` del
TDA `map` de la STL tiene complejidad O(n)


### bool LettersSet::insert(const pair<char, LetterInfo> &val)

~~~cpp
bool LettersSet::insert(const pair<char, LetterInfo> &val) {
    map<char, LetterInfo>::iterator p = letters.find(val.first); //O(1)

    if(empty()){ //O(1)                  -
        letters.insert(val); //O(log(n)) |  //O(log(n))
        return true; //O(1)              -
    }
    else{
        if (p == letters.end()){ //O(1)         -
            letters.insert(val); //O(log(n))    | //O(log(n))
            return true; //O(1)                 -
        }
        else{
            return false; //O(1)
        }
    };
}
~~~

En este caso observamos que las comprobaciones de los `if/else` tienen complejidad
O(1). En el peor de los casos por tanto la complejidad es O(log(n))


### bool LettersSet::erase(const char &key)

~~~cpp
   if(letters.erase(key) == 0){ //O(log(n))
        return true; //O(1)
    }
    else{
        return false; //O(1)
    }
}
~~~

En este caso lo único que a tener en cuenta es que la complejidad de la la comprobación
`if` es O(log(n)) al acceder al elemento por valor y no por posición. Por tanto la
complejidad es O(log(n))



### void LettersSet::clear()

~~~cpp
void LettersSet::clear(){
    letters.clear(); //O(1)
}
~~~

En este caso la complejidad es O(1).



### bool LettersSet::empty()

~~~cpp
bool LettersSet::empty() {
    return (letters.empty()); //O(1)
}
~~~

En este caso la complejidad es O(1).

### unsigned int LettersSet::size() const

~~~cpp
unsigned int LettersSet::size() const {
    return letters.size(); //O(1)
}
~~~

En este caso la complejidad es O(1)

### int LettersSet::getScore(string word)

~~~cpp
int LettersSet::getScore(string word) {
    int result = 0; //O(1)

    for (char & i : word) { //O(n)
        i = toupper(i); //O(1)
    }

    for (char & i : word) { //O(n)
        map<char, LetterInfo>::iterator p1 = letters.find(i); //O(log(n)) -
                                                                          |
        pair<char, LetterInfo> letter = *p1; //O(1)                       | O(log(n))
                                                                          |
        result += letter.second.score; //O(1)                             -
    }

    return result; //O(1)
}
~~~

En este caso, observamos que los dos bucles `for` se repiten _n_ veces. Por tanto,
tomemos el bucle con mayor complejidad dentro de él. En este caso la complejidad sería
O(nlog(n)).

### LettersSet &LettersSet::operator=(const LettersSet &cl)

~~~cpp
LettersSet &LettersSet::operator=(const LettersSet &cl) = default; //O(1)
~~~

En este caso la complejidad es O(1)

### LetterInfo &LettersSet::operator[](const char &val)

~~~cpp
LetterInfo &LettersSet::operator[](const char &val) {
    return letters[val]; //O(log(n))
}
~~~

En este caso la complejidad es O(log(n))


#### Gráfica representando la complejidad de los métodos del TDA LettersSet

@image html analisis_lettersset.png

--

## TDA Bag

Estudiaremos la eficiencia de los métodos utilizados en el TDA Bag:

### Bag<T>::Bag()

~~~cpp
template<class T>
Bag<T>::Bag(){
    this->v=vector<T>{}; //O(1)
}
~~~

En este la complejidad computacional del constructor por defecto del TDA `vector` es
O(1), por tanto la complejidad de este método es O(1)

## Bag<T>::Bag(const Bag<T> &other)

~~~cpp
template<class T>
Bag<T>::Bag(const Bag<T> &other) {
    this->v = other.v; //O(n)
}
~~~

En este la complejidad computacional del operador `=` del TDA `vector` es de O(n),
por tanto la complejidad de este método es O(n)

### void Bag<T>::add(const T &element)

~~~cpp
void Bag<T>::add(const T &element) {
    if (v.size() == 0) //O(1)
        v.push_back(element); //O(1)
    else {
        srand (1); //O(1)
        int randNum = rand()%v.size(); //O(1)
        v.push_back(v[randNum]); //O(1)
        v[randNum] = element; //O(1)
    }
}
~~~

La complejidad es O(1).

### Bag<T>::get()

~~~cpp
template<class T>
T Bag<T>::get() {
    srand (time(NULL)); //O(1)
    int randNum = rand()%v.size(); //O(1)
    T element = v[randNum]; //O(1)
    v[randNum] = v[v.size()-1]; //O(n)
    v.pop_back(); //O(1)
    return element; //O(1)
}
~~~

Observamos que sumando, obtenemos que la complejidad de este método es O(n)

### void Bag<T>::clear()

~~~cpp
template<class T>
void Bag<T>::clear() {
    v.clear(); //O(n)
}
~~~

En este caso el destructor de `vector` se vuelve constante para datos que no necesitan
ser destruidos. Pero como no sabemos el tipo de dato que toma `vector`, su complejidad
es O(n).

### unsigned int Bag<T>::size() const

~~~cpp
template<class T>
unsigned int Bag<T>::size() const {
    return v.size(); //O(1)
}
~~~

En este caso la complejidad es de O(1).

### bool Bag<T>::empty()

~~~cpp
template<class T>
bool Bag<T>::empty() {
    return v.empty(); //O(1)
}
~~~

En este caso la complejidad es O(1)

### Bag<T> &Bag<T>::operator=(const Bag<T> &other)

~~~cpp
template<class T>
Bag<T> &Bag<T>::operator=(const Bag<T> &other) {
    v = other.v; //O(n)
    return *this; //O(1)
}
~~~

En este caso la complejidad es O(n)

#### Gráfica representando la complejidad de los métodos del TDA Bag

@image html analisis_bag.png

--

## TDA LettersBag

Estudiaremos la eficiencia de los métodos utilizados en el TDA LettersBag:

### LettersBag::LettersBag()

~~~cpp
LettersBag::LettersBag() {
    letters.clear(); //O(1)
}
~~~

En este caso el destructor del vector de `Bag<char>` es lineal, por tanto la complejidad
de este método es O(1).

### LettersBag::LettersBag(const LettersSet &lettersSet)

~~~cpp
LettersBag::LettersBag(const LettersSet &lettersSet) {

    LettersSet aux_set = lettersSet; //O(1)

    for(auto it = aux_set.begin(); it != aux_set.end(); ++it) { //O(n)
        for (int j = 0; j < (*it).second.repetitions; ++j) { //O(n)
            letters.add((*it).first); //O(1)
        }
    }
}
~~~

En este caso la complejidad es O(n^2).

### void LettersBag::insertLetter(const char &i)

~~~cpp
void LettersBag::insertLetter(const char &i) {
    letters.add(i); //O(1)
}
~~~

La complejidad es O(1)

### char LettersBag::extractLetter()

~~~cpp
char LettersBag::extractLetter() {
    return letters.get(); //O(n)
}
~~~

En este caso la complejidad es O(n).

### vector<char> LettersBag::extractLetters(int num)

~~~cpp
vector<char> LettersBag::extractLetters(int num) {

    vector<char> v; //O(1)
    for (int i = 0; i < num; ++i) //O(n)
        v.push_back(letters.get()); //O(n)

    return v;
}
~~~

En este caso, multplicamos la complejidad el bucle `for` con la complejidad de su
interior y obtenemos que la complejidad de este método es O(n^2).

### void LettersBag::clear()

~~~cpp
void LettersBag::clear() {
    letters.clear(); //O(1)
}
~~~

En este caso, `clear()` si que tiene complejidad O(1) pues el tipo de dato de Bag es
`char` que no necesita ser destruido. Por tanto, la complejidad del método es O(1).

### unsigned int LettersBag::size() const

~~~cpp
unsigned int LettersBag::size() const{
    return letters.size(); //O(1)
}
~~~

En este caso la complejidad es O(1).

### LettersBag &LettersBag::operator=(const LettersBag &other)

~~~cpp
LettersBag &LettersBag::operator=(const LettersBag &other) {
    if(this != &other){ //O(1)
        this->letters = other.letters; //O(1)
    }
    return *this; //O(1)
}
~~~

En este caso la complejidad es O(1)

#### Gráfica representando la complejidad de los métodos del TDA LettersBag

@image html analisis_lettersbag.png

--

## TDA Dictionary

Estudiaremos la eficiencia de los métodos utilizados en el TDA Dictionary:

### Dictionary::Dictionary()

~~~cpp
Dictionary::Dictionary() {
    words.clear(); //O(n)
}
~~~

En este el destructor es constante por elemento y se le llama el número de elementos
que conformen el `set`, que por defecto es ninguno.
Por tanto la complejidad de este método es O(1).

### Dictionary::Dictionary(const Dictionary &other)

~~~cpp
Dictionary::Dictionary(const Dictionary &other) {
    words = other.words; //O(1)
}
~~~

Como en este caso es el constructor de copia, la complejidad del operador `=` del TDA
`set` tiene complejidad O(n). Por tanto, la complejidad de este método es O(n).

### bool Dictionary::exists(const std::string &val) const

~~~cpp
bool Dictionary::exists(const std::string &val) const {
    if(words.find(val) != words.end()){ //O(log(n))
        return true; //O(1)
    }
    else{
        return false; //O(1)
    }
}
~~~

En este caso la complejidad del método `find()` del TDA `set` tiene una complejidad
O(log(n)), por tanto la complejidad de este método reside en la comprobación del `if`
y es de O(log(n)).

### bool Dictionary::insert(const string &val)

~~~cpp
bool Dictionary::insert(const string &val) {
    if (exists(val)){ //O(log(n))
        return false; //O(1)
    }
    else{
        words.insert(val); //O(log(n))
        return true; //O(1)
    }
}
~~~

En este caso podemos observar que ambos casos del `if/else` la complejidad es O(log(n))
por tanto podemos afirmar que la complejidad de este método es O(log(n)).

### bool Dictionary::erase(const string &val)

~~~cpp
bool Dictionary::erase(const string &val) {
    if (exists(val)){ //O(log(n))
        words.erase(val); //O(log(n))
        return true; //O(1)
    }
    else{
        return false; //O(1)
    }
}
~~~

En este caso observamos que la complejidad es O(log(n)).

### void Dictionary::clear()

~~~cpp
void Dictionary::clear() {
    words.clear(); //O(n)
}
~~~

En este caso la complejidad es O(n).

### bool Dictionary::empty()

~~~cpp
bool Dictionary::empty() {
    if(size() == 0){ //O(1)
        return true; //O(1)
    }
    else{
        return false; //O(1)
    }
}
~~~

En este caso la complejidad es O(1).

### unsigned int Dictionary::size() const

~~~cpp
unsigned int Dictionary::size() const {
    return words.size(); //O(1)
}
~~~

En este caso la complejidad es O(1).

### int Dictionary::getOcurrences(const char c)

~~~cpp
int Dictionary::getOcurrences(const char c) {
    int result = 0; //O(1)

    Dictionary::iterator p1; //O(1)

    for (p1 = begin(); p1 != end(); p1++) { //O(n)
        string word = *p1; //O(1)
        int longitud = word.length(); //O(1)

        for (int i = 0; i < longitud; i++) { //O(n)
            if(word[i] == c){ //O(1)
                result++; //O(1)
            }
        }
    }

    return result;
}
~~~

En este caso multiplicando la complejidad de los `for` anidados, obtenemos que la
complejidad de este método es O(n^2).

### int Dictionary::getTotalLetters()

~~~cpp
int Dictionary::getTotalLetters() {
    int result = 0; //O(1)

    set<string>::iterator p1; //O(1)

    for(p1 = words.begin(); p1 != words.end(); p1++){ //O(n)
        string word = *p1; //O(1)
        result += word.length(); //O(1)
    }

    return result; //O(1)
}
~~~

En este caso la complejidad es O(n).

### vector<string> Dictionary::wordsOfLength(int length) const

~~~cpp
vector<string> Dictionary::wordsOfLength(int length) const {
    vector<string> result; //O(1)

    set<string>::iterator p1; //O(1)

    for(p1 = words.begin(); p1 != words.end(); p1++){ //O(n)
        string word = *p1; //O(1)

        if (word.length() == length){ //O(1)
            result.push_back(word); //O(1)
        }
    }

    return result;
}
~~~

En este caso la complejidad es O(n).

#### Gráfica representando la complejidad de los métodos del TDA LettersBag

@image html analisis_dictionary.png

--

## TDA Solver

Estudiaremos la eficiencia de los métodos utilizados en el TDA Solver:

### Métodos privados:

Para mantener los principios de ocultación de información, nos limitaremos a nombrar
los métodos privados de la clase y su complejidad computacional, sin mostrar
su código.

- __bool wordScore(vector<char> available_letters, const string &word, bool score_game)__ Eficiencia
de O(n^2)

### Solver(const Dictionary& dict, const LettersSet& letters_set)
~~~cpp
Solver::Solver(const Dictionary& dict, const LettersSet& letters_set) {
    this->dict = dict; //O(1)
    this->letters_set = letters_set; //O(1)
}
~~~

En este caso la complejidad es O(1).

### pair<vector<string>, int>getSolutions(const vector<char> & available_letters, bool score_game)

~~~cpp
pair<vector<string>, int> Solver::getSolutions(const vector<char> &available_letters, bool score_game) {

    int highest_score = 0; //O(1)
    vector<string> result; //O(1)

    const Dictionary aux; //O(1)
    Dictionary::iterator it; //O(1)

    for(it = dict.begin(); it != dict.end(); ++it){ //O(n)

        int curr_score = wordScore(available_letters, *it, score_game); //O(n^2)

        if (curr_score < highest_score) //O(1)
            continue;
        else if (curr_score > highest_score) { //O(1)
            highest_score = curr_score; //O(1)
            result.clear(); //O(n)
            result.push_back(*it); //O(1)
            cout << (*it) << endl;
        } else
            result.push_back(*it); //O(1)
    }

    pair<vector<string>, int> solutions {result, highest_score};
    return solutions;
}
~~~

Por lo tanto la eficiencia es de O(n^3)

#### Gráfica representando la complejidad de los métodos del TDA Solver

@image html analisis_solver.png
*/

